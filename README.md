# LeetCode

好多题目没有数据范围，有点不适应。

## Algorithms

### EASY:

[2.Add Two Numbers](https://leetcode.com/problems/add-two-numbers)    [5.Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring) 	[7.Reverse Integer](https://leetcode.com/problems/reverse-integer/)    [9.Palindrome Number](https://leetcode.com/problems/palindrome-number/)    [14.Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix)    [20.Valid Parentheses](https://leetcode.com/problems/valid-parentheses)       [26.Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array)    [27.Remove Element](https://leetcode.com/problems/remove-element)     [32.Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)    [35.Search Insert Position](https://leetcode.com/problems/search-insert-position) 　  [36.Valid Sudoku](https://leetcode.com/problems/valid-sudoku/)    [38.Count and Say](https://leetcode.com/problems/count-and-say)    [55.Jump Game](https://leetcode.com/problems/jump-game/)     [56.Merge Intervals](https://leetcode.com/problems/merge-intervals)    [58.Length of Last Word](https://leetcode.com/problems/length-of-last-word)    [62.Unique Paths](https://leetcode.com/problems/unique-paths) 	[63.Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)    [64.Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)    [66.Plus One](https://leetcode.com/problems/plus-one)    [67.Add Binary](https://leetcode.com/problems/add-binary)    [71.Simplify Path](https://leetcode.com/problems/simplify-path)    [78.Subsets](https://leetcode.com/problems/subsets) 	[74.Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix)   [80.Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)    [94.Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal)      [110.Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)    [118.Pascal's Triangle](https://leetcode.com/problems/pascals-triangle)    [119.Pascal's Triangle II](https://leetcode.com/problems/pascals-triangle-ii)    [121.Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)     [122.Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii)     [123.Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii)    [125.Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)    [127.Word Ladder](https://leetcode.com/problems/word-ladder)    [131.Super Ugly Number](https://leetcode.com/problems/super-ugly-number/)    [136.Single Number](https://leetcode.com/problems/single-number)    [150.Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation)    [151.Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/)    [155.Min Stack](https://leetcode.com/problems/min-stack/)    [172.Factorial Trailing Zeroes](https://leetcode.com/problems/factorial-trailing-zeroes/)    [187.Repeated DNA Sequences](https://leetcode.com/problems/repeated-dna-sequences)    [190.Reverse Bits](https://leetcode.com/problems/reverse-bits/) 　  [200.Number of Islands](https://leetcode.com/problems/number-of-islands/)   　[204.Count Primes](https://leetcode.com/problems/count-primes)    [205.Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/)    [209.Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum)      [217.Contains Duplicate](https://leetcode.com/problems/contains-duplicate)    [219.Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii)    [223.Rectangle Area](https://leetcode.com/problems/rectangle-area/)    [229.Bulls and Cows](https://leetcode.com/problems/bulls-and-cows)     [238.Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self)    [257.Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)      [263.Ugly Number](https://leetcode.com/problems/ugly-number/)    [264.Ugly Number II](https://leetcode.com/problems/ugly-number-ii)    [268.Missing Number](https://leetcode.com/problems/missing-number/) 		[278.First Bad Version](https://leetcode.com/problems/first-bad-version) 	   [283.Move Zeroes](https://leetcode.com/problems/move-zeroes)    [292.Nim Game](https://leetcode.com/problems/nim-game)    [303.Range Sum Query - Immutable](https://leetcode.com/problems/range-sum-query-immutable)    [290. Word Pattern](https://leetcode.com/problems/word-pattern)    [304.Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable)    [318.Maximum Product of Word Lengths](https://leetcode.com/problems/maximum-product-of-word-lengths)    [344.Reverse String-](https://leetcode.com/problems/reverse-string/)      [345.Reverse Vowels of a String](https://leetcode.com/problems/reverse-vowels-of-a-string/)     [413.Arithmetic Slices](https://leetcode.com/problems/arithmetic-slices/)    [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string) 	[374.Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/)    [382.Linked List Random Node-](https://leetcode.com/problems/linked-list-random-node)     [387.First Unique Character in a String-](https://leetcode.com/problems/first-unique-character-in-a-string)    [389.Find the Difference](https://leetcode.com/problems/find-the-difference/)     [392.Is Subsequence](https://leetcode.com/problems/is-subsequence)    [405.Convert a Number to Hexadecimal](https://leetcode.com/problems/convert-a-number-to-hexadecimal)    [412.Fizz Buzz-](https://leetcode.com/problems/fizz-buzz)     [414.Third Maximum Number](https://leetcode.com/problems/third-maximum-number/)    [415.Add Strings](https://leetcode.com/problems/add-strings)    [419.Battleships in a Board](https://leetcode.com/problems/battleships-in-a-board/)    [434.Number of Segments in a String](https://leetcode.com/problems/number-of-segments-in-a-string/)    [441.Arranging Coins](https://leetcode.com/problems/arranging-coins/)	[454.4Sum II-](https://leetcode.com/problems/4sum-ii)    [491.Hamming Distance](https://leetcode.com/problems/hamming-distance)    [498.Diagonal Traverse](https://leetcode.com/problems/diagonal-traverse/)    [500.Keyboard Row](https://leetcode.com/problems/keyboard-row)    [507.Perfect Number](https://leetcode.com/problems/perfect-number/)    [520.Detect Capital](https://leetcode.com/problems/detect-capital/)    [532.K-diff Pairs in an Array](https://leetcode.com/problems/k-diff-pairs-in-an-array)    [540.Single Element in a Sorted Array](https://leetcode.com/problems/single-element-in-a-sorted-array)    [541.Reverse String II](https://leetcode.com/problems/reverse-string-ii)    [553.Optimal Division](https://leetcode.com/problems/optimal-division)    [554.Brick Wall](https://leetcode.com/problems/brick-wall)     [557.Reverse Words in a String III](https://leetcode.com/problems/reverse-words-in-a-string-iii/)     [560.Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)    [567.Permutation in String](https://leetcode.com/problems/permutation-in-string)    [575. Distribute Candies](https://leetcode.com/problems/distribute-candies)    [598.Range Addition II](https://leetcode.com/problems/range-addition-ii/)    [605.Can Place Flowers](https://leetcode.com/problems/can-place-flowers)    [663.Sum of Square Numbers](https://leetcode.com/problems/sum-of-square-numbers)    [985. Sum of Even Numbers After Queries](https://leetcode.com/problems/sum-of-even-numbers-after-queries/)    [986. Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/)    [989.Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/)    [997. Find the Town Judge](https://leetcode.com/problems/find-the-town-judge/)    [999. Available Captures for Rook](https://leetcode.com/problems/available-captures-for-rook/)    [1002. Find Common Characters](https://leetcode.com/problems/find-common-characters/)    [1003. Check If Word Is Valid After Substitutions](https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/)  [1005. Maximize Sum Of Array After K Negations](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/)  [1006. Clumsy Factorial](https://leetcode.com/problems/clumsy-factorial/)   [1007. Minimum Domino Rotations For Equal Row](https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/)     [1021.Remove Outermost Parentheses](https://leetcode.com/problems/remove-outermost-parentheses/)    [1232. Check If It Is a Straight Line](https://leetcode.com/problems/check-if-it-is-a-straight-line/)    [1233. Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/)    [1234. Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/)    [1252.Cells with Odd Values in a Matrix](https://leetcode.com/problems/cells-with-odd-values-in-a-matrix)    [1253.Reconstruct a 2-Row Binary Matrix](https://leetcode.com/problems/reconstruct-a-2-row-binary-matrix)    [1254.Number of Closed Islands](https://leetcode.com/problems/number-of-closed-islands)    [5303. Decrypt String from Alphabet to Integer Mapping](https://leetcode.com/problems/decrypt-string-from-alphabet-to-integer-mapping/)    [5304. XOR Queries of a Subarray](https://leetcode.com/problems/xor-queries-of-a-subarray/)    [5305. Get Watched Videos by Your Friends](https://leetcode.com/problems/get-watched-videos-by-your-friends/)    [1374. Generate a String With Characters That Have Odd Counts](https://leetcode.com/problems/generate-a-string-with-characters-that-have-odd-counts/)    [https://leetcode.com/problems/bulb-switcher-iii/](https://leetcode.com/problems/bulb-switcher-iii/)     [1376. Time Needed to Inform All Employees](https://leetcode.com/problems/time-needed-to-inform-all-employees/)    [1377. Frog Position After T Seconds](https://leetcode.com/problems/frog-position-after-t-seconds/)    [1380. Lucky Numbers in a Matrix](https://leetcode.com/problems/lucky-numbers-in-a-matrix/)    [1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)    [1382. Balance a Binary Search Tree](https://leetcode.com/problems/balance-a-binary-search-tree/)    [1390.Create Target Array in the Given Order](https://leetcode.com/problems/four-divisors)    [1340.Four Divisors](https://leetcode.com/problems/four-divisors)    [1341.Check if There is a Valid Path in a Grid](https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid)    [1342.Longest Happy Prefix](https://leetcode.com/problems/longest-happy-prefix)    [1394.Find Lucky Integer in an Array](https://leetcode.com/problems/find-lucky-integer-in-an-array)    [1395.Count Number of Teams](https://leetcode.com/problems/count-number-of-teams)    [1396.Design Underground System](https://leetcode.com/problems/design-underground-system)

###  EASY 找规律

[89.Gray Code](https://leetcode.com/problems/gray-code)	[169.Majority Element](https://leetcode.com/problems/majority-element)    [202.Happy Number](https://leetcode.com/problems/happy-number)      [274.H-Index](https://leetcode.com/problems/h-index)    [357.Count Numbers with Unique Digits](https://leetcode.com/problems/count-numbers-with-unique-digits)    [396.Rotate Function](https://leetcode.com/problems/rotate-function)     [477.Total Hamming Distance](https://leetcode.com/problems/total-hamming-distance)    [593.Valid Square](https://leetcode.com/problems/valid-square)    [611.Valid Triangle Number](https://leetcode.com/problems/valid-triangle-number/)

### EASY 模拟

[8.String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/)    [22.Generate Parentheses](https://leetcode.com/problems/generate-parentheses)    [54.spiral-matrix](https://leetcode.com/problems/spiral-matrix)   [59.Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/)    [130.Surrounded Regions !!](https://leetcode.com/problems/surrounded-regions)    [273.Integer to English Words](https://leetcode.com/problems/integer-to-english-words)    [393.UTF-8 Validation](https://leetcode.com/problems/utf-8-validation)	[394.Decode String](https://leetcode.com/problems/decode-string)     [400. Nth Digit](https://leetcode.com/problems/nth-digit)    [401.Binary Watch](https://leetcode.com/problems/binary-watch)    [417.Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow)

### EASY 链表

[19.Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)    [24.Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs)    [61.Rotate List](https://leetcode.com/problems/rotate-list/)    [82.Remove Duplicates from Sorted List II](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii)     [83.Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list)    [86.Partition List](https://leetcode.com/problems/partition-list)    [92.Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii)    [100.Same Tree](https://leetcode.com/problems/same-tree/)    [111.Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree)     [117.Populating Next Right Pointers in Each Node II](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii)    [129.Sum Root to Leaf Number](https://leetcode.com/problems/sum-root-to-leaf-numbers/)    [143.Reorder List](https://leetcode.com/problems/reorder-list)    [160.Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)    [203.Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements/)     [206.Reverse Linked List](https://leetcode.com/problems/reverse-linked-list)    [328.Odd Even Linked List](https://leetcode.com/problems/odd-even-linked-list)

### EASY 贪心

[11.Container With Most Water](https://leetcode.com/problems/container-with-most-water)    [42.Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)    [152.Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray)   [334.Increasing Triplet Subsequence-](https://leetcode.com/problems/increasing-triplet-subsequence)    [402.Remove K Digits](https://leetcode.com/problems/remove-k-digits)    [475.Heaters](https://leetcode.com/problems/heaters/)    [561.Array Partition I](https://leetcode.com/problems/array-partition-i)    [625.Minimum Factorization](https://leetcode.com/problems/minimum-factorization/)    [665.Non-decreasing Array](https://leetcode.com/problems/non-decreasing-array)    [667.Beautiful Arrangement II](https://leetcode.com/problems/beautiful-arrangement-ii)    [1024.Video Stitching](https://leetcode.com/problems/video-stitching/) 

### EASY DP

[44.Wildcard Matching](https://leetcode.com/problems/wildcard-matching)    [53.Maximum Subarray](https://leetcode.com/problems/maximum-subarray)    [70.Climbing Stairs](https://leetcode.com/problems/climbing-stairs)    [91.Decode Ways](https://leetcode.com/problems/decode-ways)     [97.Interleaving String](https://leetcode.com/problems/interleaving-string)     [115.Distinct Subsequences](https://leetcode.com/problems/distinct-subsequences)    [139.Word Break](https://leetcode.com/problems/word-break)    [198.House Robber](https://leetcode.com/problems/house-robber)        [213.House Robber II](https://leetcode.com/problems/house-robber-ii)    [279.Prefect Squares](https://leetcode.com/problems/perfect-squares)     [322.Coin Change](https://leetcode.com/problems/coin-change)    [337.House Robber III](https://leetcode.com/problems/house-robber-iii/)   [368.Largest Divisible Subset](https://leetcode.com/problems/largest-divisible-subset)    [416.Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum)    [526.Beautiful Arrangement](https://leetcode.com/problems/beautiful-arrangement)    [639.Decode Ways II](https://leetcode.com/problems/decode-ways-ii/)    [646.Maximum Length of Pair Chain](https://leetcode.com/problems/maximum-length-of-pair-chain)    [1235. Maximum Profit in Job Scheduling](https://leetcode.com/problems/maximum-profit-in-job-scheduling/)

### EASY Tree

[98.Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)  [95.Unique Binary Search Tree II](https://leetcode.com/problems/unique-binary-search-trees-ii/)    [101.Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)    [102.Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)     [103.Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal)    [104.Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree)   [105.Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal)    [106.Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal)    [107.Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii)    [108.Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree)    [114.Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list)    [116.Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)    [124.Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum)    [144.Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal)    [145.Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal)   [199.Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/)    [226.Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree)   [230.Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)    [404.Sum of Left Leaves](https://leetcode.com/problems/sum-of-left-leaves/)    [437.Path Sum III](https://leetcode.com/problems/path-sum-iii)    [513.Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/)    [515.Find Largest Value in Each Tree Row](https://leetcode.com/problems/find-largest-value-in-each-tree-row/)    [538.Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree)    [543.Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree)    [572.Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)    [617.Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees)    [687.Longest Univalue Path](https://leetcode.com/problems/longest-univalue-path/description/)    [987. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/)    [988. Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/)    [998. Maximum Binary Tree II](https://leetcode.com/problems/maximum-binary-tree-ii/)  [1008. Construct Binary Search Tree from Preorder Traversal](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/)     [1022. Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/) 

### EASY 二分

[153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)    [154.Find Minimum in Rotated Sorted Array II * ](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii)    [275.H-Index II](https://leetcode.com/problems/h-index-ii)    [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)

### None

[73.Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes)    [201.Bitwise AND of Numbers Range](https://leetcode.com/problems/bitwise-and-of-numbers-range)    [523.Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum/)

### EASY just code it 

[6. ZigZag Conversion](https://leetcode.com/problems/zigzag-conversion/)    [17.Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)   [43.Multiply String](https://leetcode.com/problems/multiply-strings/)    [68.Text Justification](https://leetcode.com/problems/text-justification/)    [79.Word Search](https://leetcode.com/problems/word-search)    [93.Restore IP Addresses](https://leetcode.com/problems/restore-ip-addresses)    [128.Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence)   [131.Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)    [133.Clone Graph](https://leetcode.com/problems/clone-graph)    [207.Course Schedule](https://leetcode.com/problems/course-schedule)      [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree)    [210.Course Schedule II](https://leetcode.com/problems/course-schedule-ii)     [212.Word Search II](https://leetcode.com/problems/word-search-ii)    [241.Different Ways to Add Parentheses](https://leetcode.com/problems/different-ways-to-add-parentheses)    [297.Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)    [306.Additive Number](https://leetcode.com/problems/additive-number/)    [315.Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/)    [329.Longest Increasing Path in a Matrix-](https://leetcode.com/problems/longest-increasing-path-in-a-matrix)         [399.Evaluate Division](https://leetcode.com/problems/evaluate-division)    [$440.K-th Smallest in Lexicographical Order](https://leetcode.com/problems/k-th-smallest-in-lexicographical-order)    [448.Find All Numbers Disappeared in an Array](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array)    [451.Sort Characters By Frequency](https://leetcode.com/problems/sort-characters-by-frequency)    [449.Serialize and Deserialize BST](https://leetcode.com/problems/serialize-and-deserialize-bst)    [504.Base 7](https://leetcode.com/problems/base-7)      [542.01 Matrix](https://leetcode.com/problems/01-matrix)    [572.Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)    

### 代码能力

[211. Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design)    [421.Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array)

### Contest

[696.Count Binary Substrings](https://leetcode.com/contest/leetcode-weekly-contest-54/problems/count-binary-substrings/)    [697.Degree of an Array](https://leetcode.com/contest/leetcode-weekly-contest-54/problems/degree-of-an-array/)    [698.Partition to K Equal Sum Subsets](https://leetcode.com/contest/leetcode-weekly-contest-54/problems/partition-to-k-equal-sum-subsets/)    [699.Falling Squares](https://leetcode.com/problems/falling-squares/)    

### [1.Two Sum](https://leetcode.com/problems/two-sum/)

求数列中两个数加起来等于目标值。返回这两个值的索引下标。

C++中用map。O(n*log(n))的复杂度。

### [3.Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters)

在一个给定的字符串中，寻找一个没有重复元素的最长子串。Two Point问题，枚举左区间，维护右区间。

### [*4.Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays)

两个有序数组中，寻找中值。复杂度O(log(n+m))。加入要查找第k小，每次在两个数组中，比较中值的大小，进而缩小范围。

### [10.Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching) *+

含有`.*`的正则匹配判断。 `dp[i][j]`表示前i个正则串匹配前j个字符。如果是`.` or `a`的话，直接转移， 如果是`*` 的话，可能匹配0次（`dp[i-2][j]`)，可能匹配多次(`dp[i][j-1] &&(s[j] == p[i-1] || p[i-1] == '.')`)

### [12.Integer to Roman](https://leetcode.com/problems/integer-to-roman/)

Convert an integer to a [roman numeral](https://en.wikipedia.org/wiki/Roman_numerals).

Notice, 4 is IV, and 9 is IX. It's same for 40, 90, 400, 900. And converting integer to roman numeral is the same as converting a decimal number to hexadecimal.

### [13.Roman to Integer](https://leetcode.com/problems/roman-to-integer/)

It is similar to the last problem.

We can convert roman numeral to integer from high to low or low to high.

### [15.3sum](https://leetcode.com/problems/3sum/)

给定n个整数，求其中3数a,b,c。使得a+b+c = 0。返回虽有不重复的三元组。

先排序，然后枚举第一个元素。在剩余的区间上，从两端向中间逼近。复杂度O(n^2)。

注意不要重复。

### [16.3Sum Closest](https://leetcode.com/problems/3sum-closest/)

给定n个整数，找到其中3个数的和与给定的target最接近。返回这个最接近的和，题目假设只有一个最优的结果。

和之前的`3sum`系列类似。枚举第一个元素，在剩余区间，从两端到中间逼近，记录最接近的值。复杂度O(n^2)。

### [18.4sum](https://leetcode.com/problems/4sum/)

给定一个包含n个整数的数组和目标target。要求找到一个唯一的四元组(a,b,c,d)，使得a+b+c+d = target。

先排序，枚举前两个元素，然后对于后两个值，从剩余的区间的两端向中间逼近。复杂度O(n^3)。

注意四元组是唯一的，不要出现重复。

### [21.Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/?tab=Description)

把两个有序链表，合成一个有序链表。 更改指向就好了。

为了写法简单，可以初始化一个头指针，处理完返回它的.next

### [23.Merge k Sorted Lists*](https://leetcode.com/problems/merge-k-sorted-lists/)

把k个有序的链表合并为一个有序链表。暴力遍历不可行。有两种方法：

* 每次从k个链表头中取值最小的那个，这个过程可以建立一个堆来进行优化，每取一次复杂度O(log(k))。总复杂度O(m*log(k)),m是k个链表所有的节点数
* 采用merge sort的思想，分治来解决。每次合并两个有序链表。复杂度同上。

### [28.Implement strStr() #](https://leetcode.com/problems/implement-strstr/)

实现`strStr()`功能，返回一个串在另一个串第一次出现的位置。

笨方法，复杂度O(n*m)。KMP待补。

### [29.Divide Two Integers](https://leetcode.com/problems/divide-two-integers/)

给定两个整数，求他们两个的整除结果。不能使用乘、除、取模。

解法明确，二分binary search。

要注意几个地方：1）`dividend`和`divisor`可能为负数。2）结果可能溢出32的整型，比如-2^31 / -1 = 2^31

可恶的是，python本来不要注意溢出，也要强行判断是否溢出32位有符号数。

C++最好转化为`long long`来做，因为进行二分的时候可能会相加溢出。

### [30.Substring with Concatenation of All Words*](https://leetcode.com/problems/substring-with-concatenation-of-all-words)

给一个字符串S，还有一个字符串集合T，其中所有字符串长度一样。要求找出所有S中的子串，满足这个子串包含所有T中字符串的一种排列。

可以利用字符串集合中长度一致，每次从某个起点出发，以字符串长度为一节。然后类似之前的Two Point问题，遍历左区间，维护右区间。

### [31.Next Permutation](https://leetcode.com/problems/next-permutation/)

找到一个排列的字典序下的下一个排列。如果已经是字典序上的最后一个排列，返回字典序最小的排列。

不用额外的空间。因为字典序，要从后往前考虑。从最后一位往前看，如果都是递增的，说明这一块是字典序较大的，还要往前找，找到一个不递增的，就是我们寻找next permutation的机会。

首先，从最后往前寻找，找到第一个递减的。例如，`51342`第一个递减的就是`4->3`。

然后，从这个递减的位置到最后一位中寻找到比递减位置数字大的最小的数字，和递减的位置进行交换。例如，`51342`递减的位置是第三位，数字`3`，后面数字`42`中比它大的最小的数字是`4`，进行交换，得到`51432`。

最后，对递减位置后面部分进行排序。例如，将上一步得到的`51432`，第三位后面的进行排序得到`23`。则结果为`51423`。

如果第一步找不到递减，则把这个排列进行排序。

### [33.Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)

把一个有序的数组错位了一下，给定一个数找出其下标。肯定是O(log(n))，可以通过两次二分，第一次确定这个截断位置，第二次对这两段有序数组分别二分。

还有一种写法就是在原有普通二分的基础上进行修改。

### [34.Search for a Range](https://leetcode.com/problems/search-for-a-range)

利用二分，在一个有序数组里面找到目标值的区间。

### [37.Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)

让你补全一个数独，仅有一个解。

搜索，每一个空位的确定，影响到3个方向。我写的时候，找到一个解就直接返回，不过在中间少一个这个的判断，调试好久。

### [39.Combination Sum](https://leetcode.com/problems/combination-sum/)

给一个正整数的集合c，和目标值T。从c中取出数字，每个数字可以用多次，数字和为T,求这些组合。

直接搜索。

### [40.Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)

和上一个类似，不过集合中每一个数字只能用一次。

还是搜索，只是每次不重复选择。

### [*41.First Missing Positive](https://leetcode.com/problems/first-missing-positive/)

输入一串整数，输出一个最小的不在其中出现的正整数。

输入中负数和大于输入长度的整数可以排除掉，不会影响结果。就在剩下的[1,length]中找到第一个没出现的就好。可以把它看成一种特殊的排序--桶排序。通过不断的把一个数字移动到它应该在的位置，检查第一个不在它应有位置的数字。

### [45.Jump Game II](https://leetcode.com/problems/jump-game-ii/)

贪心。假如，走1步可以最多到达x1，那么第二步可以最多到达的x2,一定来自于[1, x1], x2 = max(i+numx[i]) for i in [1, x1]，依次类推。

### [46.Permutations*](https://leetcode.com/problems/permutations/)

生成全排列，O(n!)。

递归来实现，第一位和他后面的分别进行交换，然后第二位和他后面的分别交换……这样依次得到的并不是字典序的。

### [47.Permutations II](https://leetcode.com/problems/permutations-ii/)

和上题类似，不过要求排列不重复。

通过例子，观察可知，如果重复出现，一定是在上题的步骤中，某一位和他后面的进行交换后，这位出现重复的数字。判断一下就解决了。

### [48.Rotate Image](https://leetcode.com/problems/rotate-image/)

给一个n*n的matrix，把它顺时针转一下。不借助额外的空间，找一下坐标对应就好。

### [49.Group Anagrams](https://leetcode.com/problems/anagrams/)

 给一些字符串，要求把只有字母顺序不同的字符串放在一起。

直接排序就好。

### [50.Pow(x, n)](https://leetcode.com/problems/powx-n/)

题目思路并不难,进行移位操作，复杂度O(log(n))。但是注意一下:

1.n可能是负数 。

2.n可能是-2^31.这种情况比较极端，在我们做法中，先进行转化为正数，然后对结果取倒数，再取反。在转化为正数的时候，就有问题，`n = -n`，得到的还是`-2^31`，无效。然后，进行右移的位操作`>>`，当int时负数的时候，右移的时候左面补的是符号位`1`，永远不可能为0，所以TLE。

解决办法就是转化为long long，就避免了这个极端情况出现的问题。

### [51.N-Queens](https://leetcode.com/problems/n-queens/)

经典递归回溯问题。在n*n棋盘中，放置n个棋子，每两个不同行不同列，不同两个方向的斜线。

可以简单的搜索下每次不和前面的冲突。比较高效的方式是使用位运算压缩一下到每行的不可达的位置。

### [57.Insert Interval](https://leetcode.com/problems/insert-interval)

在intervals里面插入一个interval，合并有覆盖的区间。思路不难，写的好丑。

### [60.Permutation Sequence](https://leetcode.com/problems/permutation-sequence/)

给定n,k。求在1~n的全排列中字典序为k的排列是哪个。

可以通过[康拓展开](https://zh.wikipedia.org/zh/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80)，它是一个双射，由一个排列到其字典顺序的一个双射，也是它的一个哈希函数。

### [69.Sqrt(x)](https://leetcode.com/problems/sqrtx/)

比较简单，实现`int sqrt(int x)`。

由于结果是一个整数，直接二分就好，复杂度O(log(x))。

### [72.Edit Distance](https://leetcode.com/problems/edit-distance) *

dp。`dp[i][j]`表示word1前i个字母，编辑到word2的前j个字母的距离。

`dp[i][j] = dp[i-1][j-1] if word1[i] == word2[j] else min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1`

### [75.Sort Colors](https://leetcode.com/problems/sort-colors/)

不要用STL中的sort，把含有`0 1 2`的串排序。

* 1, 先统计一下分别的数量，然后写入。
* 2,荷兰国旗问题，通过设置三个指针`low` `current` `high`，进行排序，可以根据某个中间值，分成低中高三段。

### [76.Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring)

给出两个字符串S、T，求在S中一个最小长度的子串，要求这个子串包含所有T中的字符。

设置一个区间[l, r]，每次r向右移动，直到当前区间符合要求，然后l向右移动，直到再移动就不符合要求。现在是一个符合要求的[l,r]区间。然后l向右移动一下，重复上面的步骤直到结束。

### [77.Combinations](https://leetcode.com/problems/combinations/)

给n,k。从1...n里面取出k个，把不同的组合全部输出（c(k,n)个)。DFS一下就可以。

### [81.Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)

和33题一样，区别是可能有重复元素。开始一直在想O(log(n))的解法。无果，然后发现只有一种平均O(log(n))，最坏O(n)的方法。

### [84.Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)*

直方图里面找最大的矩形块。比较直接的想法是，枚举每一小块，以它的高度为矩形的宽度，长度需要向左向右枚举，直接枚举的话，算法总复杂度是O(n^2)。可以设置l[],r[]，表示它向左可以多少，向右可以多少，减少重复计算。复杂度接近O(n)。

### [85.Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/)*

给一个01矩阵，求里面只包含`1`的最大矩形块面积。

如果和上面这道题目结合，就没什么难度了。外面多循环一次。算法复杂度接近O(n^2)。

### [88.Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)

给定两个有序的数列A,B，把两个和并成一个有序的数列，并且存放到A里面。

如果使用额外存储空间的话，很容易。不使用额外存储空间的话，可以倒序添加到A的末尾。

### [99.Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree)

注意bst中序遍历是sorted array的特点。

### [90.Subset II](https://leetcode.com/problems/subsets-ii/)

一个有重复元素的集合。求它所有不重复的幂集。

注意相同元素的处理，这部分是无序处理的。

### [95.Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/) *

n个不同值组成的BST的种类数。dp[i]表示i个不同大小的值组成BST的数量。$dp[i] = \sum_{j=0}^{i-1}dp[j]*dp[i-1-j]$ ，因为实在枚举根节点的值，根节点为1时，左面0个，右面i-1个；根节点为2时，左面1个，右面i-2个……

### [109.Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/) *

之前是sorted array to bst，这是list to bst。仔细分析，可以发现这个list其实是一个中序遍历，所以写一个中序遍历dfs依次读取即可。

### [112.Path Sum I](https://leetcode.com/problems/path-sum/)

判断存在一个二叉树从根到底的和为给定值，遍历一下树就可以。

### [113.Path Sum II](https://leetcode.com/problems/path-sum-ii/)

在上一个的题意上，给出这个路径，思路一样。

### [120.Triangle](https://leetcode.com/problems/triangle/)

动态规划，可以使用滚动数组，仔细想想可以发现一维就够了。

### [126.Word Ladder II](https://leetcode.com/problems/word-ladder-ii/)

单词字母替换，每次只能替换一个，求最短的替换路径。

先bfs求最短，同时记录路径。然后dfs还原路径。

### [132.Palindrome Partitioning II](https://leetcode.com/problems/palindrome-partitioning-ii/) *

动态规划。`dp[i]`表示从i到length区间，最小的分割数。`dp[i]=min(dp[i], dp[j-1]+1) if s[j:i] is palindrome for i in range(lenght) for j in range(i)`

### [134.Gas Station](https://leetcode.com/problems/gas-station/)

环形一共n个加油站，每个提供gas[i]油，每段路消耗cost[i]个。求是否可以从某个点出发绕一圈，如果可以输出可以的唯一起点。

发现，假设从某一个起点出发，到达最后一个点，如果结果为负数，则不可能。如果不为负数，那么累加结果最小的点的下一个点为最优的起点。

### [135.Candy](https://leetcode.com/problems/candy/)

给N个小孩分糖吃，每个小孩有一个优先级。满足，每个小孩至少一个糖，如果这个小孩比旁边小孩的优先级高，那么他的糖的数量也要高。求最少给他们分多少个糖。（好抠）

考虑，如果是优先级升序，那么分的糖的数量也升序；如果优先级降序，那么分的糖是降序，不能出现1以下的数量。开始糖数，从左到右全部为1，如果优先级变高，那么比他左面人的糖数加一；同样从右向左搞一遍。然后每个人的糖数，是这两次处理的max。O(n)。

### [*137.Single Number II](https://leetcode.com/problems/single-number-ii/)

除了一个数字只出现一次，其余都出现3次。记录每一位出现的次数，把出现次数mod 3==1的组合起来，就是结果。

还可以用两个int记录只出现一次和只出现两次的二进制，最后取出第一个int，就是结果。

### [*138.Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer)

深拷贝一个带有随机指针的链表。最优的复杂度O(n)。

先将原有链表的下一个指针指向拷贝的节点，然后拷贝的节点的下一个指针指向原有节点的下一个节点。然后弄好随机指针，最后恢复原有链表和拷贝链表的指针。

### [140.Word Break II](https://leetcode.com/problems/word-break-ii) *

求一个无分隔的词，可以用字典中词分隔开，求所有的分隔结果。DFS，但是必须记忆化。`map<string, vector<string>> `

### [141.Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)

对于一个链表，判断是否有环，最好不要用额外的空间。

泪目，当初面过某家的实习，被问到过，本来挺简单，后来问不要用额外的空间，怎么弄。当时有点懵。

设置两个指针，开始都指向头，一个指针一次跳一步，另一个一次跳两步。如果两个指针在不到达末尾之前可以相遇，那么有环。

### [*142.Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)

和上到题目一样，要求出环的起始点。

在上一题的基础上，一个比较直观的想法是：先求出环的长度k，从链表的头开始向后找，如果这个当前这个节点向后k个节点是自己，这个点就是环的起始点。但是这样复杂度是O(n^2)，写了一下竟然A了，812 ms，看了一下有比较快的算法，那么最优的算法估计复杂度还是O(n)。

假设起点是`X`，环的起点是`Y`，上个题目做法中第一次相遇的点是`Z`，`X`到`Y`的距离是a，`Y`到`Z`的距离是b，`Z`到`Y`的距离是c，环的长度为L=b+c。

那么，`2*(a+b) = a+n*L+b, n>=1`，即慢指针走过的距离的2倍等于快指针走过的距离。得到`a+b = n*L, n>=1`。

观察这个式子发现`a = n*L-b = (n-1)*L+c, n>=1`,即a的距离等于c的距离加上n-1倍的环的长度。那么，可以想到，设置两个指针，一个在起点`X`，一个在相遇点`Z`，两个指针每次都走一步，那么现在的相遇点就是环的起点`Y`了。这个算法复杂度O(n)。

### * [146.LRU Cache](https://leetcode.com/problems/lru-cache/) 

设计实现LRU  Cache,要求get和put操作都是O(1)的。这样在查询的时候，就要用到hash table。而为了确认当满了，要删除哪个的时候，就要利用链表来实现这个操作。

### [147.Insection Sort List](https://leetcode.com/problems/insertion-sort-list/)

对链表插入排序。。注意转换思维，不要拿数组那一套直接用。

### [148.Sort List*](https://leetcode.com/problems/sort-list/?tab=Description)

对于一个无序的链表，在O(log(n))的复杂度内对其排序，要求常数的空间复杂度。

采用归并排序的思想，分治来解决。(可以使用快慢指针来找出中间位置)

### [149.Max Points on a Line](https://leetcode.com/problems/max-points-on-a-line) *

求点集中，最多多少个点共线。O(n^2)。

枚举第一个点，遍历第二个点，然后map一下斜率。这个过程认为O(1)。

### [162.Find Peak Element](https://leetcode.com/problems/find-peak-element/)

给定一个数列num[1~n] 假定`num[0] = num[n+1] = -INF`，求peak值的索引，peak值就是大于左右两个相邻的值。由于num[0], num[n+1]都是负无穷大，所以一定优解，要求O(log(n))的复杂度，可以进行二分。当二分到某个值，比较它的左右值，如果是peak，则找到任一解；如果是上升的，继续二分右区间；否则二分左区间。这样可以一定得到任一解。

### [164.Maximum Gap](https://leetcode.com/problems/maximum-gap) *

bucket sort。

### [165.Compare Version Numbers](https://leetcode.com/problems/compare-version-numbers/)

给两个版本号，比较那个版本高。

注意，`0.01 == 0.1`, `0.1.0 == 0.1`。

### [166.Fraction to Recurring Decimal](https://leetcode.com/problems/fraction-to-recurring-decimal/)

分数转为小数，若有循环节要标明。可以发现循环节大小不会超过分母的大小，把小数部分的余数，每次x10，取余数，依次进行。如果余数出现重复，则有循环节出现。注意两种情况,-INF的出现，分子为0

### [173.Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator)

实现BST的hasNext()和next()函数，就是保存状态的二叉树的中序遍历。

### [174.Dungeon Game *](https://leetcode.com/problems/dungeon-game)

从矩阵左上走到右下，求最少的初始血量值。开始直接二分搜索这个血量值，正向做的。

然后看别人的做法有直接动态规划做的，效率更优。设`dp[i][j]为进入格子(i,j)之前需要的最少血量`，状态转移为右下到左上的转移。

### [179.Largest Number](https://leetcode.com/problems/largest-number)

把整数按照字符串进行拼接，求出最大的拼接结果。整体上是按照字典序排序，但是注意`34`,`34341` 这种情况，修改一下排序函数就好。

### [* 188.Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv)

股票买入卖出，最多交易k次的最大利润。动态规划，而不能简单的用一个`dp[i][j]`表示在第i天，j次交易内达到的最大利润。因为状态转移无法只靠这一个状态完成。

两个状态：`dp1[i][j]`表示在第i天，j次交易且第i天卖出，能获得的最大利润。`dp2[i][j]`表示在第i天之前，j次交易能获得的最大利润。状态转移：`dp1[i][j] = max(dp2[i-1][j-1] + max(0,diff), dp1[i-1][j] + diff); dp2[i][j] = max(dp1[i-1][j], dp2[i-1][j])`。此外还要注意如果k比较大，就退化成了没有k约束的问题了，这种情况下O(n)解决。

### [189.Rotate Array](https://leetcode.com/problems/rotate-array)

可以reverse3段。

### [191.Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)

求32-bit integer中写成二进制`1`的个数。从末尾依次找即可，O(log(n)) 解决。

### [214.Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome) #* #

回文即正反一样，则我们把原字符串翻转，然后拼接在后面，求尾部的next数组即可。

### [216.Combination Sum III](https://leetcode.com/problems/combination-sum-iii/)

和39,40类似。要求从[1,9]之间找出不重复的k个数之和等于n。还是直接搜索DFS

### [215.Kth Largest Element in an Array *](https://leetcode.com/problems/kth-largest-element-in-an-array)

在一个无序的数组里面找到第k大的数字，也就是c++，STL里面`nth_element()`的功能。 

可以借助快排中partition，每次随机挑选一个值，把他放到应该在的位置，左面都比他小，右面都比他大。然后看k-th在他左面还是右面，继续进行partation.

### [220.Contains Duplicate III * ](https://leetcode.com/problems/contains-duplicate-iii/)

在一个数组中，寻找这样的i, j，使得abs(i-j) <= k and abs(nums[i] - nums[j] ) <= t。

用map维护一个大小为k的nums[i], i。每次map的keys里面二分大于等于nums[x]-t的最小数字，看看是否符合要求。

### [221.Maximal Square](https://leetcode.com/problems/maximal-square)

`dp[i][j]`表示以(i, j)为右下角可以得到的最大正方形边长。

`dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 if matrix[i][j] == '1'`

### [222.Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes/)

`O((log(n)^2)`

### [224.Basic Calculator](https://leetcode.com/problems/basic-calculator/)

给一个包含非负数、`+`、`-`、`(`、`)`和空格的字符串，求出它的值。

利用栈，依次入栈，遇到`)`的时候，依次出栈并计算，直到遇到`(`，并把计算的值入栈。最后对栈上的内容进行计算。

复杂度O(n)。

### [225.Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/)

让你使用queue的相关操作，实现stack。

push、empty没啥可说的。pop()操作应该在queue上去队前的元素放到队后，最后一个元素只取出来。top()类似。

python中的queue使用`from collections import deque`。

### [227.Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)

给一个包含非负数、`+`、`-`、`*`、`/`和空格的字符串，要求求出它的值，输入一定是合法的。

不用像224用栈来做了，只需要遇到加减，把之前的值全部处理完，遇到乘除把之前乘除块的值处理完。

O(n)。

### [229.Majority Element II *](https://leetcode.com/problems/majority-element-ii)

类似169. Majority Element， 设置两个记录，最后再验证一下。

### [231.Power of Two](https://leetcode.com/problems/power-of-two/)

判断一个数是否是2的幂。方法很多，随便一种就好。

### [232.Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)

使用Stack中的操作，来实现Queue。

和225类似，对于pop()和peek()需要借助两个queue倒腾一下。

### [233.Number of Digit One](https://leetcode.com/problems/number-of-digit-one/)

给一个n，求[1,n]中所有数字含有`1`的数量。题目一看，有点数位DP的意思。

把这个问题分解成，求[1,n]中只含有1个`1`的数字的个数、只含有两个`1`的数字的个数，……，只含有len(n)个`1`的数字的个数。

这些子问题，分别用动态规划来解，dp(i,j)表示不达到最大值`n`边界的情况下，在第i位（从高位算起），在状态为j的情况下数字的个数。假设求区间内包含k个`1`的数字个数，j就取得0~k，表示从第i位到最后一位包含`1`的个数为j。状态转移见代码吧，不好描述。

可以用记忆化搜索来实现。如果在边界，就不能用到已有的dp(i,j)的值。如果输入足够大，结果会溢出，但是OJ并没有这样的数据。

### [234.Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/) *

O(1)空间 O(n)复杂度判断一个链表是否是回文。需要把后半段reverse一下，然后在顺序判断。

### [235.Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

在一个二叉查找树上找某两个节点的LCA，直接按照大小直接搜一下就好。复杂度大约是树的深度。

### [236.Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) *

在一个二叉树上找某两个节点的LCA。可以搜一遍，假设n个节点，复杂度O(n)。


### [237.Delete Node in a Linked List](https://leetcode.com/problems/delete-node-in-a-linked-list/)

删除链表中的一个节点（不是尾节点），不过只给出这个节点的访问。

我们可以把下一个节点的值复制到该节点，然后删除下一个节点。

### [239.Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum)*

单调队列经典题目。使用deque实现单调队列。

### [240.Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/) *

一个矩阵，从左到右，从上到下，都是递增的。确定一个值是否存在，O(n+m)。

### [242.Valid Anagram](https://leetcode.com/problems/valid-anagram/)

判断两个字符串是否包含的字母只是顺序不同。直接判断就好。

### [258.Add Digits](https://leetcode.com/problems/add-digits)

`abc = a*100^2 + b*10 + c = a + b + c (mod 9)`

### [260.Single Number III](https://leetcode.com/problems/single-number-iii)

找出出现次数为单次的两个数字。 先全部异或一次，找到异或结果中最后一位1，分别按照这位是否为1，进行异或，可以得到a, b。

### [282.Expression Add Operators](https://leetcode.com/problems/expression-add-operators/)

给一个只含有数字的字符串和一个目标整数值，可以往数字串里面添加`+`,`-`,`*`,来使得计算值等于目标整数值。

注意不能有前导0.

暴力枚举字符串每个间隔位的符号，+-*或者什么没有，然后计算。然而TLE。

看到有人用搜索，递归来写。

写了一发，就过了。amazing。

### [284.Peeking Iterator](https://leetcode.com/problems/peeking-iterator)

每次要预算出下一次的值，来做cache。学到调用父类方法。

### [287.Find the Duplicate Number*](https://leetcode.com/problems/find-the-duplicate-number)

现在有n+1个整数，他们在[1,n]区间内，其中只有一个数字出现里多次。求这个数字。

可以二分，二分目标值，每次统计比它小的个数。O(n*log(n))

可以类似[142.Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) ,肯定有环，找出环的入口位置，就是结果。O(n)。

### [289.Summary Ranges](https://leetcode.com/problems/summary-ranges/)

给一个有序的整数串，要求返回它的各个整数区间，单个值返回自己，不返回区间。例如`[0,1,2,4,5,7]`,返回 `["0->2","4->5","7"].`

依次判断一下就好了，复杂度O(n).

### [295.Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)

O(log(n)), O(1)

### [300.Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence) *

经典题目LIS，最朴素的dp，O(n^2)。还有通过二分的O(n*log(n))的解法，因为在某个位置之前，能组成的某个长度的LIS的最小值是递增的。

### * [330.Patching Array](https://leetcode.com/problems/patching-array)

贪心，智商题。只需要记录并更新

### [307.Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/)

树状数组, Binary Index Tree。

### [309.Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

买卖股票。可以进行无数多次交易，但是任意两次交易不能有交叉，而且中间至少隔一天。如果没有隔一天的限制的话，就是把所有升序的求和即可。限制的限制就是两个交易之间至少隔开**两段**。动态规划， O(n) 。 `dp[N][3], dp[i][0] = max(dp[i-1][0] + num, dp[i-1][2]+num), dp[i][1] = dp[i-1][0], dp[i][2] = max(dp[i-1][1], dp[i-1][2])`

### [310.Minimum Height Trees](https://leetcode.com/problems/minimum-height-trees) *

可以类似求拓扑序的方式进行求，最终的结果要么1个，要么两个。

### [312.Burst Balloons](https://leetcode.com/problems/burst-balloons)

有一个数组，每个数字非负，每次选择一个数字，他和他旁边的两个数字相乘取积，然后把这个数字去掉。指导所有的数字都被去掉，求这个积的和最大是多少。

区间DP,复杂度O(n^3)。`dp[i][j]`表示从i到j区间，在不去掉区间边际值(即位置i和j的数字)的情况下，能得到的最大的和。

状态转移:`dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i]*nums[j]*nums[k]) for k in range(i+1, j)`

### [319.Bulb Switcher](https://leetcode.com/problems/bulb-switcher)

一串灯泡，开始全关，第一次按1的倍数的灯泡的开关，第二次按2的倍数的灯泡的开关……直到第n次。求最后多少亮着。

可以发现，如果一个灯泡是亮的，它被按了奇数次。而且这个灯泡的次序是一个平方数。

也就是求解[1,n]多少个平方数。sqrt(n)个平方数。O(1)。

### [* 324.Wiggle Sort II](https://leetcode.com/problems/wiggle-sort-ii)

给定一个无序数组，要求把它排列成数字一大一小，摆动的样子。

O(n)时间复杂度，O(1)额外空间。 首先通过O(n)找出median，根据中值，把他们分成3部分，大于median的，等于median的和小于median的。然后把它们错位组织，例如`5442` -> `4524`。

### [326.Power of Three](https://leetcode.com/problems/power-of-three/) *

不用递归、循环判断一个数n是否是3的幂。

找到一个不超过2^31-1的最大的3^n，如果这个3^n mod n是否为0。

### [327.Count of Range Sum](https://leetcode.com/problems/count-of-range-sum) **

调试了好久。题目是找区间的数量，这个区间是区间的数字和位于某个区间内。首先求前1~n的和，排序，去重（离散化）。然后依次从左到又累加，利用树状数组，求符合区间条件的数量。

### [331.Verify Preorder Serialization of a Binary Tree](https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree)

(1)这个序列实际是一个先序遍历，可以dfs判断一下，要注意判断长度是否满足

(2)其实有一个比较巧妙的办法，通过入度出度判断，任意时刻的出度的数量不应该小于0.

### ** [332.Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary)

有一些飞机票，往返地点，来求“一笔画”，如果出现多个方案，则给出字典序最小。利用dfs，达到题目要求，写起来非常简单。只是在回溯的时候再加入返回列表，最后再reverse一下。

### [335.Self Crossing](https://leetcode.com/problems/self-crossing/) *

给一个整数串，依次代表一个点分别向上、向左、向下、向右……走的距离。问是否会出现交叉。

就是依次进行顺时针移动。可以发现，每个方向的时候，只有3中不同的相交情况。

1)第j条线撞到第j-3条线 。 2)第j条线追尾第j-4条线。 3)第j条线撞到第j-5条线。

细心判断下就好。

### [336.Palindrome Pairs*](https://leetcode.com/problems/palindrome-pairs)

给出distinct的字符串，找出所有的<i,j>， 字符串i拼接上字符串j是一个回文串。

开始写了O(n^3)的TLE，可以有`O(n*k^2)`。 因为各不相同，可以通过map<string,int>来进行快速查找。

### [338. Counting Bits](https://leetcode.com/problems/counting-bits/)

It's easy to solve this problem by O(n*log(n)) algorithm. 

But we can make use of what we have produced already. The time complexity of this dynamic programming algorithm is **O(n)**. 

For num`i` and `i-1` , it's only different for the low part in their binary format. For example, number 23(10111) and 24(11000), the high part `1`  is same, the another part `0111` and `1000` is different. We can get the result of `11000` by the result of  number `10000` (set the low part to zero).

solution: **result[i] = result[i & (i-1)] + 1.**

### [341.Flatten Nested List Iterator-](https://leetcode.com/problems/flatten-nested-list-iterator/) *

把多层的list，依次遍历，把简单递归可以完成的事情，用非递归完成。为了效率注意使用iterator。

注意c++ STL容器不能存放引用。注意使用iterator, stack<>.top() 可以直接进行修改。

### [342.Power of Four](https://leetcode.com/problems/power-of-four/)

判断一个整数n，是否是4的幂。不适用循环和递归。

那就用对数来判断，log4(n)是否是整数，注意浮点数0的判断。

### [343.Integer Break](https://leetcode.com/problems/integer-break/)

给一个数n，它可以写成k个数的和(k>1)，现在求这k个数乘积最大是多少。

假设，k是固定的，那么n分成尽可能均匀的k份是最优的，能得到最大的乘积。这时，乘积最大的方案唯一。

题目说n最大58，遍历k的长度就可以，复杂度O(n)。

还可以发现随着k从2开始增大到n，这个最优乘积先增大后减小。所以可以用三分进行找最优解，复杂度为$$O(log_3n)$$。

### [347. Top K Frequent Elements-](https://leetcode.com/problems/top-k-frequent-elements)

在一个数组中找到出现频率最高的k个元素。

可以用的方法， 先统计每个的出现次数，然后使用heap。或者使用桶排序。

### [349.Intersection Of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/)

给两个整数串，返回其中重复出现的整数，不要求有序，而且返回的整数中必须唯一。

把两个整数串分别放入两个set中，两个set取并。

### [350.Intersection of Two Array II-](https://leetcode.com/problems/intersection-of-two-arrays-ii/)

给两个整数数组，返回在两个中都出现的元素，如果有重复也要返回重复。

分别给两个数组排序，然后对两个数组从小到大依次判断是否重复。复杂度O(n\*log(n) + m\*log(m))。

其实，如果n或者m很大，可以采用O(n*m)的方法。 

### [354.Russian Doll Envelopes](https://leetcode.com/problems/russian-doll-envelopes) *

很容易想到O(n^2)的解法。如果要O(n log(n))，就要在第一关键字从小到大，第二关键字从大到小，然后求LIS。这样排序是为了避免同样大小的第一关键字嵌套。

### [365.Water and Jug Problem](https://leetcode.com/problems/water-and-jug-problem) *

求gcd，然后判断

### [367.Valid Perfect Square](https://leetcode.com/problems/valid-perfect-square/)

判断一个数是否是完全平方数。

和[69.Sqrt(x)](https://leetcode.com/problems/sqrtx/) 类似。二分，复杂度O(log(n))。

### [373.Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums)

在两个有序数组中，找到top k小的pair<i,j>。

使用优先队列，复杂度O(k*log(k))。有点类似与23.Merge K Sorted List

### [375.Guess Number Higher or Lower II](https://leetcode.com/problems/guess-number-higher-or-lower-ii/)

在区间[1,n]中给定某个数字，你可以进行猜是哪个数字。每次告诉你，你猜的数字是等于/大于/小于目标数字。每次猜测的花费是你猜的数字的值。为了保证无论给定的目标数字是什么，你都有足够的费用去猜中，这个费用最少是多少。

开始还想着O(log(n))。没有数据规模只能瞎想。最后只能想到O(n^2)的解法。区间dp，dp(i,j)表示查找区间[i,j]之间任何数字的最少费用。

### [377.Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/?tab=Description)

给一个正整数集合，eg，`nums = [1, 2, 3]`，给一个目标值,eg,`target = 4`。

取nums里面一些数，其和为target。可以重复取，顺序不同算作不同的序列。求这些不同序列的个数。

动态规划，dp[i]表示用nums里面的数字，组成i大小的序列数。for num in nums : dp[i] =dp[i] + dp[i-num] 

如果按照背包的那种状态转移方式，得到的是不考虑次序的序列个数。

### [378.Kth Smallest Element in a Sorted Matrix-](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/) *

* 优先队列，复杂度大约O(k*log(n))
* 二分， O(log(INF)*n) 。这个比较好。

### [372.Super Pow](https://leetcode.com/problems/super-pow/)

求a^b,不过b可能非常的大，所以它以vector(c++)、list(python)为参数。

原本可以O(log(b))的复杂度解决的，现在由于这种参数形式，我们二进制的思路解法转化为十进制的解法，复杂度也就变成了O(log_10(b))。

如果用C++写，注意取模，不要溢出。

### [380.Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1)

O(1)实现 insert, remove, getRandom方法。可以使用hash_table和数组。每个操作理想下O(1)。

### [384.Shuffle an Array-](https://leetcode.com/problems/shuffle-an-array/)

shuffle一个数组，可以从头到位依次，每个位置和它及后面的元素范围内，等概率交换。

### [391.Perfect Rectangle *](https://leetcode.com/problems/perfect-rectangle)

可以发现某一个点，如果在最后组成的矩形里面，必定为小矩形的顶点，且出现偶数次。最后组成的大矩形的顶点出现一次。

### [395.Longest Substring with At Least K Repeating Characters- *](https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters)

找出满足这样条件的最长子串的长度，其中每个出现的字母的出现次数不小于k。

利用mask记录26个字母中是否符合要求，注意左区间的移动步数。

### [397.Integer Replacement](https://leetcode.com/problems/integer-replacement)

给一个数字，经过两种操作`n/2` or `n+1` or `n-1`。问最少几次操作，变为1.

写成二进制，每一位都要右移一下，对于`1`，只有一个的话，直接减去，两个以上加上一。注意一下末尾处理。

### [398.Random Pick Index-](https://leetcode.com/problems/random-pick-index/) *

题目要在一个非常大的array里面，输出给定target的随机index。在不适用额外空间的情况下，可以考虑使用[水塘抽样](https://zh.wikipedia.org/wiki/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A8%A3)。 基础版可见[382.Linked List Random Node](https://leetcode.com/problems/linked-list-random-node)

### [406.Queue Reconstruction by Height](https://leetcode.com/problems/queue-reconstruction-by-height)

给定n个pair，每个包括这个数字的值和他前面大于等于他的数量。

贪心。从pair里面第二个数字比较小的开始放，而且尽可能往后放。

### [410.Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum)

n个数字，分成m份。使得最大的区间和最小。求这个最小值。

二分这个区间块的和。

### [424.Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement)

O(n)

### [442.Find All Duplicates in an Array](https://leetcode.com/problems/find-all-duplicates-in-an-array)

只包含1~n的n个数字，找出出现次数为2的所有数。换成原位置就可以

### [445.Add Two Numbers II](https://leetcode.com/problems/add-two-numbers-ii/)

两个链表代表的数字相加。改动原位置和不改动。

### [450.Delete Node in a BST](https://leetcode.com/problems/delete-node-in-a-bst)

写的要优美

### [* 456.132 Pattern](https://leetcode.com/problems/132-pattern)

找到形如`132`大小排列的3个数字。从右往左去，维护第三个数字的最大值`third`，再维护一个third值的候选stack。对于每个值，如果小于third，则成功。如果作为中间的数字，则可以更新stack。如果作为第三个数字，直接push到stack里面。

### [464.Can I Win*](https://leetcode.com/problems/can-i-win)

在整数1~n中，两个玩家依次不放回的取一个数字，玩家的得分为取出数字的和，得分先打到预定值x的获胜。问先手玩家能否获胜。

博弈，用Minimax算法思想，要注意记忆化搜索，复杂度O(2^n)。如果不记忆化，复杂度O(n!)。

### [474.Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/)

给出许多只含有`0`,`1`的串，求当0和1的个数分别为m,n的情况下，能组成多少个串。

简单背包，DP。只是重量变成了二维，价值为1。

### [*480.Sliding Window Median](https://leetcode.com/problems/sliding-window-median/)

求滑动窗口的中值。还是用两个heap实现，分别存放窗口大小的一半。插入值，对比top值，选择插入的heap。删除时，用hash记录一下，哪些需要删除，当top遇到这些值的时候，删除即可。

### [486.Predict the Winner*](https://leetcode.com/problems/predict-the-winner)

一些非负整数，两个人博弈，轮流从这些数的两端取出一个数，最后谁的数字和大，谁赢。判断先手是否能赢。

可以直接进行搜索。其实，这是这种博弈可以用[Minimax算法](https://zh.wikipedia.org/wiki/%E6%9E%81%E5%B0%8F%E5%8C%96%E6%9E%81%E5%A4%A7%E7%AE%97%E6%B3%95) ，每个节点设置启发值，当前所选数字减去剩余区间启发值，叶子节点启发值就是该数字大小。

### [* 493.Reverse Pairs](https://leetcode.com/problems/reverse-pairs)

找i>j , nums[i] > 2\*nums[j]的个数。

最开始，写了一个Trie，发现没考虑负数的情况WA。

后来写了个,BST，发现题目卡非平衡二叉树，TLE。

最后，采用树状数组BIT(Binary Index Tree)，依次在数组中以他应该在的位次放入nums[j]，在放之前查询下在已经放入的j个数字中有多少大于2\*num[j]的数字（需要二分确定2\*num[j]的应在位置)。复杂度O(n*log(n))。

### [494.Target Sum](https://leetcode.com/problems/target-sum)

给一个数组整数，在前面加上`+` `-` 使得结果为S。求多少种方案。

动态规划+滚动数组

### [496.Next Greater Element I *](https://leetcode.com/problems/next-greater-element-i)

找到一个数字，下一个比它大的数字。利用stack，如果一个数字找到了比它大的就出栈，栈里面是始终是非递增的。O(n)

### [503.Next Greater Element II  ](https://leetcode.com/problems/next-greater-element-ii/)

和496的区别是数组构成一个环，还是利用stack，第一次遍历全部加入，第二次只是比较不加入。

### [517.Super Washing Machines](https://leetcode.com/problems/super-washing-machines/)

每个洗衣机有不同数量的衣服，每次可以选择任意某些洗衣机，把其中一件衣服往相邻的洗衣机转移。求最少多少次转移。

贪心。以每个洗衣机为中心，要么从它像两边转移，要么两边向他转移，要么从一边到另一边转移。最少的转移次数，是这些得到的最小值。

### [525.Contiguous Array](https://leetcode.com/problems/contiguous-array)

给一个只含有0 1的数组，求里面最长的区间长度，区间内01个数相等。

考虑O(n)的复杂度，可以算出来每个位置，从头到现在0比1多的个数。只要任何两个位置这个数字相等就算合格的区间。

首先把每个位置这个值算出来，统计一下这些值所在位置的最大下标和最小下标。求出这个差值的最大值。

### [*546.Remove Boxes](https://leetcode.com/problems/remove-boxes)

一个数组，不同的数值代表不同的类别，每次可以消去连续的同类别的数字，获得价值为消去区间长度的平方；余下的组成新的数组。求最多可以获得多少价值。

动态规划。`dp[l][r][m]` 代表区间[l, r]，在之前有m个数字和num[l]相同的情况下，可以获得的最大价值和。多加一维的原因是，这样可以转移到子区间来求解，完整的表达状态。`dp[l][r][m]=max(dp[l][r][m], dp[l][i][0] + dp[i+1][r][m+1]) for i in range(l, r+1) if num[i] == num[l]`

### [552.Student Attendance Record II](https://leetcode.com/problems/student-attendance-record-ii/)

动态规划，每个未知只有3种放置方法。和前两位有关系，前两位的状态一种3种，`x0` `01` `11`， 还要记录是否出现过了`A`， 所以一共6中状态。每个位置的状态由上一位的状态转移得到。

这样是O(n)。如果这个转移过程写成矩阵的形式，可以通过矩阵快速幂得到，O(log(n))。

### [556.Next Greater Element III](https://leetcode.com/problems/next-greater-element-iii)

给一个正整数，找出这样的正整数，这个正整数包含的数字和之前以前，而且它是之前的next greater number。

贪心一下，从末尾开始，找到第一个非递增的数字，然后用后面比他大的最小的数字进行交换，然后把后面的进行排序。

### [621.Task Scheduler*](https://leetcode.com/problems/task-scheduler)

给定一些任务，相同类别的任务之间要有n个时间间隔，要么用其他任务隔开，要么空闲时间隔开。

贪心，最优的一种排列方法，就是先把出现最多的依次放在大小为n+1的间隔里面。

### [650. 2 Keys Keyboard*](https://leetcode.com/problems/2-keys-keyboard/)

初始有一个字母`A`,有两种操作，复制之前所有的字符，粘贴上一次复制的内容。求得到正好n个需要多少次操作。

dp[i] 表示得到正好i个字母所需要的最少操作数。dp[i] = min (dp[i], dp[j] + i / j if i %j == 0)

### [672.Bulb Switcher II*](https://leetcode.com/problems/bulb-switcher-ii/)

有4种操作灯泡的方式，问给你n个灯泡，m次机会。灯泡的序列有多少种状态。

可以发现当n>=3 && n>=3的时候，结果==8。其余情况特殊分析。

### [990.Satisfiability of Equality Equations](https://leetcode.com/problems/satisfiability-of-equality-equations/)

使用并查集。首先处理`==`的，因为只考虑这些是没有冲突的，先建立集合关系。

然后再处理`!=`，如果属于同一集合，则冲突。

### [*991.Broken Calculator](https://leetcode.com/problems/broken-calculator/)

X to Y, by X=X-1 or X= X*2。反过来思考，如果由Y到X，要么是+1，要么是/2。

如果`X>Y`，那么只能进行X=X-1。

当Y是奇数的时候，一定要`+1`，不可能是由X*=2得到的。

当Y是偶数的时候，一定要进行`/2`，因为如果是`X+1`，`(X+1+1)/2==X/2+1`不是最优的。

### [*992.Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/)

2e4大小的数组，每个数字[1,length]。找到满足子区间内有k个不同数字的子区间的个数。

可以找到这样的规律，如果确定子区间的开始位置left，肯定有[right1,right2]内任意的坐标right，使得[left,right]区间满足恰好有k个不同数字，且right2>=right1。

时间复杂度`O(n)`

### [1001.Grid Illumination](https://leetcode.com/problems/grid-illumination/)

在content的时候，居然用`O(n*m)`给过了。

实际上可以用行、列、正对角、斜对角的hash来计算。复杂度`O(n)`

###[*1000. Minimum Cost to Merge Stones](https://leetcode.com/problems/minimum-cost-to-merge-stones/)

contest的时候没做出来。想到了如果只merge两堆的区间dp的解法，但是没发散到这个题目。

解法还是区间dp，状态`dp[i][j][k]`表示在区间`[l,r]`内聚出k堆的cost值。

状态转移，`dp[i][j][k] = dp[i][m][k-1] + dp[m+1][j][1]` 且`dp[i][j][1] = dp[i][j][K] + sums[i:j]`

结果要求的是`dp[1][n][1]`

### [1023. Camelcase Matching](https://leetcode.com/problems/camelcase-matching/)

只可以插入小写字母，判断是否可以插入得到目标字符串。

注意一些case，比如不一定有大写字母，开头不一定以大写字母开始。

### [1255.Maximum Score Words Formed by Letters](https://leetcode.com/problems/maximum-score-words-formed-by-letters)

给一些字母的集合，每个字母有一个价值，再给定一个待组成的字符串集合。求用字母集合可以组成的字符串的最大价值。由于字符串集合最多n=14个，直接暴力求解即可，时间复杂度O(2^n*len)，其中len为字符串的长度。

### [5306. Minimum Insertion Steps to Make a String Palindrome](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

对于一个字符串(长度小于500)，使用最少的插入次数，使得字符串成为回文串。
区间DP，dp[i][j]表示使区间i到j成为回文串的最少插入次数, (1)i>=j, dp[i][j] = 0, (2)s[i]==s[j], dp[i][j]=dp[i+1][j-1], (3)dp[i][j] = min(dp[i+1][j], dp[i][j-1])+1

### [1383. Maximum Performance of a Team](https://leetcode.com/problems/maximum-performance-of-a-team/)

长度为`n`的两个序列，找到`k`个对应数字，第一个序列中k个数字的和和第二个序列中k个数字的最小值的乘积。
按照第二个序列逆序排列，依次从第一个序列依次取top k大的数字（用小根堆实现）。时间复杂度`O(n*log(n))`

### [*1397.Find All Good Strings](https://leetcode.com/problems/find-all-good-strings)

一道很不错的题目，求等长的两个字符串`a`和`b`之间不包含子串`c`的字符串个数。
数位dp，`dp[i][j]`表示前i位，状态为j，在0到上限字符串之间有多少满足的数字。其中有一个坑，在j这个状态的转移中，有类似KMP的思维，不能直接置0。详见代码。

## Database

[595.Big Countries](https://leetcode.com/problems/big-countries)

### [175. Combine Two Tables](https://leetcode.com/problems/combine-two-tables)

Person表是主表，Address表是从表，通过Left Outer Join左外连接

### [176.Second Highest Salary](https://leetcode.com/problems/second-highest-salary)

在select后使用()内查询。

### [177.Nth Highest Salary](https://leetcode.com/problems/nth-highest-salary)

函数的写法。

### [178.Rank Scores](https://leetcode.com/problems/rank-scores)

类似176的写法 。

### [180.Consecutive Numbers](https://leetcode.com/problems/consecutive-numbers)

两个`inner join` 自连接

### [181.Employees Earning More Than Their Managers](https://leetcode.com/problems/employees-earning-more-than-their-managers)

`inner join`

### [182.Duplicate Emails](https://leetcode.com/problems/duplicate-emails)

`group by` , `having`

### [183.Customers Who Never Order](https://leetcode.com/problems/customers-who-never-order/)

使用`not in` 或者使用`left join` 只留`is NULL`

### [184.Department Highest Salary](https://leetcode.com/problems/department-highest-salary)

多级嵌套查询.

### [185.Department Top Three Salaries](https://leetcode.com/problems/department-top-three-salaries/)

父语句中的项可以在子语句中用到。

### [196.Delete Duplicate Emails](https://leetcode.com/problems/delete-duplicate-emails)

注意update/delete，如果where中用到相同的表，要加上`select * from (原本的where中语句) as t`,因为如果不这么做，更新和where中的操作是交替进行的，这样做就成了先后进行的。

### [197.Rising Temperature](https://leetcode.com/problems/rising-temperature)

`inner join` , `to_days()`

### [*262.Trips and Users](https://leetcode.com/problems/trips-and-users)

自己写的挺繁琐的，处理`group by ` count为0不显示的问题(用left join ifnull(xx,0)判断)，然后看到别人写法很简洁。

`round(sum(case when t.Status like 'cancelled_%' then 1 else 0 end)/count(*),2) Rate`

### [596.Classes More Than 5 Students](https://leetcode.com/problems/classes-more-than-5-students)

类似 182.

### [601. Human Traffic of Stadium](https://leetcode.com/problems/human-traffic-of-stadium)

两次`inner join`

### [620.Not Boring Movies](https://leetcode.com/problems/not-boring-movies)

简单

### [626. Exchange Seats](https://leetcode.com/problems/exchange-seats/)

交换id

### [627.Swap Salary](https://leetcode.com/problems/swap-salary)

`update salary set sex = if(sex='m', 'f', 'm');`

`update salary set sex = char(ASCII(sex) ^ ASCII('m') ^ ASCII('f'));`

## Shell

### [192Word Frequency](https://leetcode.com/problems/word-frequency)

`cat words.txt | tr -s ' ' '\n' | sort | uniq -c | sort -rn | awk '{print $2 " " $1}'`

### [195.Tenth Line](https://leetcode.com/problems/tenth-line)

`sed -n 10p file.txt` 

